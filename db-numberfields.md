# Database numberfields

Status: Released

Contact/Maintainer: John Jones

Description: Global number fields

Todo:
* Add more data on siblings
* Possibly add narrow class groups
* Possibly add more class group/unit information


## Collection fields
* **_id**: ObjectId generated by Mongo DB (includes creation timestamp)
  **Example:** ObjectId('4fac7fa90eb55b6ff200002f')
* **label** (string): LMFDB label, formed by joining the degree, number of real places, absolute discriminant, and index with ".".  The index is a counter to distinguish fields which would otherwise have the same label
  **Example:** '11.1.52713545163946191360000000000.1'
* **degree** (int): degree of the field over **Q** 
  **Example:** 11
* **coeffs** (list of ints as string): coefficients of our defining polynomial starting with the constant term.
* **reduced** (int 0 or 1): 1 if the polynomial is the output of polredabs, otherwise 0.
  **Example:** 1
* **coeffhash** (string): output of hexdigest applied to coeffs -- it can be used as an index for coefficient lookup (coeffs can be too long)
  **Example:** 'c187070bd71b8ab0a64176f5bc999046'
* **disc_abs_key** (string of digits): the absolute discriminant prepended by 3 digits which give the number of digits minus one, as a string.  This is because discriminants get too big to store as ints, but we want to be able to sort on them  
  **Example:** 02852713545163946191360000000000
* **disc_sign** (int): 1 or -1 depending on the sign of the discriminant
  **Example:** 1
* **dischash** (int): integer to be used for indexing discriminants when the disc_abs_key gets to be too long.  Code to compute it is below
  **Example:** -285271354516394619
* **signature** (list of ints as string): signature (r_1, r_2) of the field stored as r_1,r_2
  **Example:** '1,5'
* ** ramps** (list of ints as strings): the ramified primes in a list.  Stored as strings because they may be too big
  **Example:** ['2', '3', '5', '11']
* ** all_ramps ** (list of ints as string): the list of ramified primes, separated by commas, as a single string  
  **Example:** '2,3,5,11'

The dischash is computed as follows, assuming the disc_abs_key is stored as d:
        if len(d)<19:
          dhash=int(dak)
        else:
          dhash = int(d[0:19])
        dhash = dhash * disc_sign
